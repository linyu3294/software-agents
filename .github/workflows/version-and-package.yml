name: Version and Package Documentation

on:
  push:
    branches: [ main, master ]

jobs:
  version-and-package:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      packages: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
      
      - name: Determine version bump
        id: version
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"
          
          # Remove 'v' prefix if present
          LATEST_VERSION=${LATEST_TAG#v}
          echo "Latest version: $LATEST_VERSION"
          
          # Check commit messages for version bump type
          COMMITS=$(git log ${LATEST_TAG}..HEAD --oneline --pretty=format:"%s")
          echo "Commits since last tag:"
          echo "$COMMITS"
          
          # Default to patch version bump
          VERSION_TYPE="patch"
          
          # Check for breaking changes or major version indicators
          if echo "$COMMITS" | grep -i "BREAKING CHANGE\|major:" > /dev/null; then
            VERSION_TYPE="major"
          # Check for new features
          elif echo "$COMMITS" | grep -i "feat\|feature\|minor:" > /dev/null; then
            VERSION_TYPE="minor"
          fi
          
          echo "Version bump type: $VERSION_TYPE"
          echo "version_type=$VERSION_TYPE" >> $GITHUB_OUTPUT
          
          # Calculate new version using basic shell arithmetic
          if [ "$LATEST_VERSION" = "0.0.0" ]; then
            NEW_VERSION="1.0.0"
          else
            IFS='.' read -r major minor patch <<< "$LATEST_VERSION"
            case $VERSION_TYPE in
              major)
                NEW_VERSION="$((major + 1)).0.0"
                ;;
              minor)
                NEW_VERSION="$major.$((minor + 1)).0"
                ;;
              patch)
                NEW_VERSION="$major.$minor.$((patch + 1))"
                ;;
            esac
          fi
          
          echo "New version: $NEW_VERSION"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "new_tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
          
          # Store commits for release notes
          echo "commits<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Create and push tag
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          git tag ${{ steps.version.outputs.new_tag }}
          git push origin ${{ steps.version.outputs.new_tag }}
      
      - name: Build package
        run: |
          # Create a dist directory with the packaged content
          mkdir -p dist
          
          # Copy all markdown files and directories
          find . -name "*.md" -not -path "./.git/*" -not -path "./dist/*" | while read file; do
            # Create directory structure in dist
            dir=$(dirname "$file")
            mkdir -p "dist/$dir"
            cp "$file" "dist/$file"
          done
          
          # Copy the agents directory if it exists
          if [ -d "agents" ]; then
            cp -r agents/ dist/
          fi
          
          # Create a version file
          echo "${{ steps.version.outputs.new_version }}" > dist/VERSION
          
          # Create a manifest file
          {
            echo "Software Agents Documentation Library"
            echo "Version: ${{ steps.version.outputs.new_version }}"
            echo "Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
            echo ""
            echo "Contents:"
            find dist -type f -name "*.md" | sort
          } > dist/MANIFEST.txt
          
          # Create a tarball and zip file
          tar -czf software-agents-${{ steps.version.outputs.new_version }}.tar.gz -C dist .
          cd dist && zip -r ../software-agents-${{ steps.version.outputs.new_version }}.zip . && cd ..
          
          echo "Packages created:"
          echo "- software-agents-${{ steps.version.outputs.new_version }}.tar.gz"
          echo "- software-agents-${{ steps.version.outputs.new_version }}.zip"
      
      - name: Create GitHub Release
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.version.outputs.new_tag }}
          release_name: Software Agents Documentation ${{ steps.version.outputs.new_tag }}
          body: |
            ## Software Agents Documentation Library ${{ steps.version.outputs.new_tag }}
            
            This release contains a packaged version of the software agents documentation that can be used as a library in other projects.
            
            ### ðŸ“¦ Package Contents
            - Agent documentation files (`agents/` directory)
            - Workflow and collaboration documentation
            - Version information and manifest
            
            ### ðŸ“‹ Changes in this version
            ${{ steps.version.outputs.commits }}
            
            ### ðŸš€ How to use
            
            Download one of the packages below and extract it into your project:
            
            ```bash
            # Using tar.gz
            wget https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.new_tag }}/software-agents-${{ steps.version.outputs.new_version }}.tar.gz
            tar -xzf software-agents-${{ steps.version.outputs.new_version }}.tar.gz
            
            # Using zip
            wget https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.new_tag }}/software-agents-${{ steps.version.outputs.new_version }}.zip
            unzip software-agents-${{ steps.version.outputs.new_version }}.zip
            ```
            
            Or reference it as a git submodule:
            ```bash
            git submodule add --name software-agents https://github.com/${{ github.repository }}.git libs/software-agents
            cd libs/software-agents
            git checkout ${{ steps.version.outputs.new_tag }}
            ```
          draft: false
          prerelease: false
      
      - name: Upload Tarball Release Asset
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./software-agents-${{ steps.version.outputs.new_version }}.tar.gz
          asset_name: software-agents-${{ steps.version.outputs.new_version }}.tar.gz
          asset_content_type: application/gzip
      
      - name: Upload Zip Release Asset
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./software-agents-${{ steps.version.outputs.new_version }}.zip
          asset_name: software-agents-${{ steps.version.outputs.new_version }}.zip
          asset_content_type: application/zip
